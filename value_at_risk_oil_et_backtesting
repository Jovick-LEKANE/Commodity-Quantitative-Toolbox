import yfinance as yf
import numpy as np
import pandas as pd

class RiskManager:
    def __init__(self, ticker):
        # 1. Téléchargement et nettoyage strict du MultiIndex de yfinance
        df = yf.download(ticker, start="2022-01-01")
        if isinstance(df.columns, pd.MultiIndex):
            self.data = df['Close'][ticker]
        else:
            self.data = df['Close']
            
        # 2. Calcul des rendements (on enlève les NaN)
        self.returns = np.log(self.data / self.data.shift(1)).dropna()

    def backtest_var(self, confidence=0.95):
        window = 252
        # 3. Calcul de la VaR glissante (on veut le quantile du bas, ex: 0.05)
        # On calcule le quantile sur les rendements réels
        var_series = self.returns.rolling(window=window).quantile(1 - confidence).dropna()
        
        # 4. Alignement
        aligned_returns = self.returns.loc[var_series.index]
        
        # 5. TEST CRUCIAL : Une exception est quand Rendement < VaR
        # Comme VaR est négatif (ex: -0.03) et Rendement est négatif (ex: -0.04)
        # -0.04 < -0.03 est VRAI -> C'est une exception.
        exceptions = aligned_returns[aligned_returns < var_series]
        
        failure_rate = len(exceptions) / len(aligned_returns)
        
        return {
            "Confidence": confidence,
            "Total Days": len(aligned_returns),
            "Exceptions": len(exceptions),
            "Failure Rate": failure_rate,
            "Expected Rate": 1 - confidence,
            "Mean VaR": var_series.mean()
        }

# --- TEST ---
risk = RiskManager("BZ=F")
for conf in [0.95, 0.99]:
    res = risk.backtest_var(conf)
    print(f"\n--- Results for VaR {res['Confidence']*100:.0f}% ---")
    print(f"Mean VaR Level: {res['Mean VaR']:.2%}")
    print(f"Exceptions: {res['Exceptions']} / {res['Total Days']}")
    print(f"Real Failure Rate: {res['Failure Rate']:.2%}")
    print(f"Status: {'VALID' if res['Failure Rate'] < 0.10 else 'ERROR'}")
